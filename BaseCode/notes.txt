* 配置模块导入路径
    sys.path.append('xxoo')

* 重新导入模块
    from imp import reload
    reload(xxoo)

* 模块循环导入问题
    解决方法：设计时避免

* ==与is的区别

* 深拷贝与浅拷贝
    深拷贝使用：import copy
    a = copy.deepcopy(b)

    - 注意copy.copy与copy.deepcopy的区别
    - 注意copy.copy拷贝元组时的特点

* 进制和位运算
    进制之间的转换，使用函数：bin()/int()/hex()/oct()

* 私有化
    _X: 单前置下划线，私有化属性或方法，仅本模块使用，from xxx import *时禁止导入
    __X: 双前置下划线，私有化属性或方法，避免与子类中的属性名冲突，无法在外部直接访问

* property的使用
    -property函数
    -property装饰器

* 可迭代对象和迭代器
    可以直接作用于for循环的对象称为可迭代对象
    判断可迭代对象的方法：
    from collections import Iterable
    isinstance(xxx, Iterable)

    -可以被next()函数调用并返回下一个值的对象称为迭代器：Itertor
    判断迭代器的方法：
    from collections import Iterator
    isinstance(xxx, Iterator)

    -将一个可迭代对象变成迭代器使用iter()函数
    a = iter(a)

* 闭包

* VIM注释多行方法
    末行模式： %s/^/#/g 每行开头加上#号
               %s/#//g  将每行的#号替换为空
               1,,10s///g  指定行

* 装饰器

* 作用域
    globals()函数
    locals()函数
    __builtin__

* Python动态添加属性和方法
    给对象动态绑定属性和方法
    给类动态绑定属性和方法
    - 给对象动态绑定方法：
        import types
        xxxObj.xxxFunc = types.MethodType(xxxFunc, xxxObj)
    - 静态方法与类方法的添加

* 生成器

* 对象的__call__方法

* 类当装饰器
    class C(object):
        def __init__(self, func):
            self.__func = func

        def __call__(self):
            self.__func()

* 元类
    使用type('className', (parentClass,...), {'propertyName': value})创建类对象
    __metaclass__属性

* 小整数对象池
    [-5, 257] - 不包括257

* 大整数对象池

* intern机制
    a = 'aaa'
    b = 'aaa'
    a与b内存地址相同

    a = 'a a'
    b = 'a a'
    a与b内存地址不同（字符串中包含特殊字符）

* Garbage collection(GC垃圾回收)
    - 引用计数
        import gc
    - Ruby的标记清除
    - Python的隔代回收
    - 查看一个对象的引用计数
        import sys
        a = 1
        sys.getref(a)

* 内建属性
    __getattribute__

* 内建方法

* 集合

* 偏函数
    import functools

* 常用模块
    builtins
    os
    sys
    functools
    json
    logging
    multiprocessing
    threading
    copy
    time
    calender
    hashlib
    random
    re
    socket
    shutil
    glob

* 常用扩展库
    requests
    urllib
    scrapy
    beautifulsoup4
    celery
    redis
    Pillow(PIL)
    xlsxwriter
    xlwt
    xlrd
    elasticsearch
    pymysql
    pymongo
    matplotlib
    numpy/scipy
    django
    tornado
    flask
    xmltodict
    SimpleHTTPServer
    gevent
    fabric
    pandas
    scikit-learn

* PDB调试
    python -m pdb xxx.py
    l - 显示当前的代码
    n - 向下执行一行代码
    c - 继续执行代码
    b - 设置断点
    clear - 删除断点
    s - step 单步执行，可进入函数
    a - args 打印出所有的形参数据
    p - 打印变量的值
    q - quit 退出调试
    r - return 快速执行到函数的最后一行

    交互调试
    import pdb

    pdb.run('xxx(args)')
    pdb.set_trace()

* PEP8编码规范

* 多进程
    - Linux系统中使用os.fork()
    - multiprocessing模块(可跨平台)
        from multiprocessing import Process
        - 使用Process类
        - 创建Process的子类

* 进程池Pool
    from multiprocessing import Pool

* 进程间通信
   - Queue
   - 进程池中的Queue
        from multiprocessing import Manager, Pool
        q = Manager().Queue()

* 多线程
    - thread模块
    - threading模块
        - threading.Thread
        - 使用threading.Thread的子类

* 线程共享全局变量

* 可变类型和不可变类型当实参

* 互斥锁
    - 避免死锁

* 生产者消费者模型

* threading.local

* 同步与异步
    from multiprocess import Pool
    pool = Pool(3)
    pool.apply_async(func=xxx, callback=ooo)

* GIL的问题
    - 可以使用C语言来解决GIL问题
        from ctypes import *
        from threading import Thread
        lib = cdll.LoadLibrary("./libxxx.so")
        t = Thread(target=lib.xxxFunc)
        t.start()
        #lib.xxxFunc()











