* 配置模块导入路径
    sys.path.append('xxoo')

* 重新导入模块
    from imp import reload
    reload(xxoo)

* 模块循环导入问题
    解决方法：设计时避免

* ==与is的区别

* 深拷贝与浅拷贝
    深拷贝使用：import copy
    a = copy.deepcopy(b)

    - 注意copy.copy与copy.deepcopy的区别
    - 注意copy.copy拷贝元组时的特点

* 进制和位运算
    进制之间的转换，使用函数：bin()/int()/hex()/oct()

* 私有化
    _X: 单前置下划线，私有化属性或方法，仅本模块使用，from xxx import *时禁止导入
    __X: 双前置下划线，私有化属性或方法，避免与子类中的属性名冲突，无法在外部直接访问

* property的使用
    -property函数
    -property装饰器

* 可迭代对象和迭代器
    可以直接作用于for循环的对象称为可迭代对象
    判断可迭代对象的方法：
    from collections import Iterable
    isinstance(xxx, Iterable)

    -可以被next()函数调用并返回下一个值的对象称为迭代器：Itertor
    判断迭代器的方法：
    from collections import Iterator
    isinstance(xxx, Iterator)

    -将一个可迭代对象变成迭代器使用iter()函数
    a = iter(a)

* 闭包

* VIM注释多行方法
    末行模式： %s/^/#/g 每行开头加上#号
               %s/#//g  将每行的#号替换为空
               1,,10s///g  指定行

* 装饰器

* 作用域
    globals()函数
    locals()函数
    __builtin__

* Python动态添加属性和方法
    给对象动态绑定属性和方法
    给类动态绑定属性和方法
    - 给对象动态绑定方法：
        import types
        xxxObj.xxxFunc = types.MethodType(xxxFunc, xxxObj)
    - 静态方法与类方法的添加

* 生成器

* 对象的__call__方法

* 类当装饰器
    class C(object):
        def __init__(self, func):
            self.__func = func

        def __call__(self):
            self.__func()

* 元类
    使用type('className', (parentClass,...), {'propertyName': value})创建类对象
    __metaclass__属性

* 小整数对象池
    [-5, 257] - 不包括257

* 大整数对象池

* intern机制
    a = 'aaa'
    b = 'aaa'
    a与b内存地址相同

    a = 'a a'
    b = 'a a'
    a与b内存地址不同（字符串中包含特殊字符）

* Garbage collection(GC垃圾回收)
    - 引用计数
        import gc
    - Ruby的标记清除
    - Python的隔代回收
    - 查看一个对象的引用计数
        import sys
        a = 1
        sys.getref(a)

* 内建属性
    __getattribute__

* 内建方法

* 集合

* 偏函数
    import functools

* 常用模块
    builtins
    os
    sys
    functools
    json
    logging
    multiprocessing
    threading
    copy
    time
    calender
    hashlib
    random
    re
    socket
    shutil
    glob

* 常用扩展库
    requests
    urllib
    scrapy
    beautifulsoup4
    celery
    redis
    Pillow(PIL)
    xlsxwriter
    xlwt
    xlrd
    elasticsearch
    pymysql
    pymongo
    matplotlib
    numpy/scipy
    django
    tornado
    flask
    xmltodict
    SimpleHTTPServer
    gevent
    fabric
    pandas
    scikit-learn

* PDB调试
    python -m pdb xxx.py
    l - 显示当前的代码
    n - 向下执行一行代码
    c - 继续执行代码
    b - 设置断点
    clear - 删除断点
    s - step 单步执行，可进入函数
    a - args 打印出所有的形参数据
    p - 打印变量的值
    q - quit 退出调试
    r - return 快速执行到函数的最后一行

    交互调试
    import pdb

    pdb.run('xxx(args)')
    pdb.set_trace()

* PEP8编码规范

* 多进程
    - Linux系统中使用os.fork()
    - multiprocessing模块(可跨平台)
        from multiprocessing import Process
        - 使用Process类
        - 创建Process的子类

* 进程池Pool
    from multiprocessing import Pool

* 进程间通信
   - Queue
   - 进程池中的Queue
        from multiprocessing import Manager, Pool
        q = Manager().Queue()

* 多线程
    - thread模块
    - threading模块
        - threading.Thread
        - 使用threading.Thread的子类

* 线程共享全局变量

* 可变类型和不可变类型当实参

* 互斥锁
    - 避免死锁

* 生产者消费者模型

* threading.local

* 同步与异步
    from multiprocess import Pool
    pool = Pool(3)
    pool.apply_async(func=xxx, callback=ooo)

* GIL的问题
    - 可以使用C语言来解决GIL问题
        from ctypes import *
        from threading import Thread
        lib = cdll.LoadLibrary("./libxxx.so")
        t = Thread(target=lib.xxxFunc)
        t.start()
        #lib.xxxFunc()

* socket网络编程
    import socket
    - socket是全双工
* UDP与TCP

* 编码问题

* wireshark抓包工具

* tftp下载过程分析
    - tftp协议
    - pack与unpack的使用
        import struct
        send_data = struct.pack('!H8sb5sb', 1, 'test.jpg', 0, 'octet', 0)
        a_tuple = struct.unpack('!HH', recv_data[0:4])

* UDP广播
    -如果需要发送广播数据，则需要设置允许广播
        dest = ('<broadcast>', 8888)    #广播地址
        setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    - 只有UDP可以广播，TCP不可以广播

* TCP通信
    - packet tracer工具

* 交换机和集线器的区别
    - 集线器都是广播
    - 交换机可以记录通信地址

* arp和icmp协议
    - icmp ping的时候使用
    - arp 获取电脑的MAC地址
    - rarp 根据mac找ip

* 命令 arp -a 查看ARP缓存列表

* 路由器
    - 确定一条路径的设备
    - 路由器有多个网卡，可以连接多个不同网段

* ping的过程
    - mac地址在两个设备之间通信时在变化，而IP地址在整个通信过程中保持不变
    - ip标记逻辑上的地址，mac标记实际转发时的设备地址，netmask和ip地址一起来确定网络号
      默认网关发送的ip不在同一个网段内，那么会把这个数据转发给默认网关

* TCP十种状态
    LISTEN
    SYN_SENT
    SYN_RECV
    ESTABLISHED
    FIN_WAIT1
    CLOSE_WAIT
    FIN_WAIT2
    LASK_ACK
    TIME_WAIT
    CLOSED

* TTL
    - 经过路由器的个数

* 2MSL问题
    - 一个数据包在网络上的存活时间

* listen的队列长度

* 常见的网络攻击
    - TCP半链接攻击
    - dns攻击
    - arp攻击

* nslookup baidu.com

* cdn 内容分发

* python使用原始套接字

* NAT
    - 网络地址转换

* 调制解调器（猫）
    - 把电信号转换成网络信号

* WAN和LAN

* TCP服务器
    - 单进程服务器
    - 多线程服务器
    - 多进程服务器
    - 单进程非堵塞服务器

* cow写时拷贝

* select服务器
    - select是跨平台的
    - 轮询方式进行检测

* poll服务器
    - 解决了select最多监听1024个套接字的上限问题
    - 轮询方式进行检测

* epoll服务器
    - 采用事件通知机制

* 协程
    - 又称微线程
    - 通过yield关键字实现
    - 协程实现多任务需要手动切换

* 计算密集型和IO密集型
    - 计算密集型需要占用大量的CPU资源
    - IO密集型需要网络功能，大量时间都在等待网络数据的到来

* greenlet实现多任务
    - 需要手动切换

* gevent实现多任务
    - 遇到IO操作自动切换，可自动识别IO操作

* 网络层级关系
    - 四层模型
        应用层 --> 解决要传递什么数据
        传输层 --> 解决如何传输数据
        网络层 --> 可以理解为地理位置
        链路层 --> 具体的传输工具

* HTTP协议









